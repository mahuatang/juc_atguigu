package 项目实战;

import cn.chineseall.bcus.entity.cardaccount.CardAccount;
import cn.chineseall.bcus.mapper.account.AppAccountMapper;
import cn.chineseall.bcus.mapper.cardaccount.CardAccountMapper;
import cn.chineseall.bcus.service.cardaccount.CardAccountService;
import cn.chineseall.book3.mapper.user.UserMergeMapper;
import org.nqcx.commons.dao.DaoInterface;
import org.nqcx.commons.lang.o.DTO;
import org.nqcx.commons.service.ServiceSupport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.*;

@Service("cardAccountService")
public class CardAccountServiceImpl extends ServiceSupport implements CardAccountService {
    private final static Logger logger = LoggerFactory.getLogger(CardAccountServiceImpl.class);
    @Autowired
    private CardAccountMapper cardAccountMapper;

    @Autowired
    private UserMergeMapper userMergeMapper;

    @Autowired
    private AppAccountMapper appAccountMapper;

    @Qualifier("bcusTransactionManager")
    @Autowired
    private PlatformTransactionManager transactionManager;

    private static final int Thread_NUMBERS = 50;

    @Override
    public boolean insertCardBatch(final Integer batchId, final long appId, final Integer quantity, final short lengthNumber, final Date activateTime, final Date useEndTime, final Integer timeLength, short setWay) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        transactionManager.getTransaction(def);

        //查询数据库中是否存在同类型的卡号
        long count = this.queryCount(new DTO().putParam("appId", appId).putParam("cardIncrementNumber", lengthNumber));
        long maxStartNumber = 0;
        //计算生成阅读卡的自增起始位置
        if (count > 0) {
            String numberStr = "";
            int length = lengthNumber;
            while(length-- != 0) {
                numberStr += 9;
            }
            int maxEndNumber = Integer.valueOf(numberStr);
            if (maxEndNumber <= count + quantity) {
                logger.error("当前定制的阅读卡种类将超出上限-------->>>>appId:[{}], lengthNumber:[{}]", appId, lengthNumber);
                return false;
            }
            maxStartNumber = count + 1;
        } else {
            maxStartNumber = 1;
        }

        //计算所有待生成的阅读卡号
        List<String> cardList = new LinkedList<String>();
        for (int i = 0; i < quantity; i++) {
            String cardId = appId + String.format("%0" + lengthNumber + "d", maxStartNumber) + lengthNumber;
            cardList.add(cardId);
            maxStartNumber++;
        }

        final long t1 = System.currentTimeMillis();
        final List<String> userMergeResult = userMergeMapper.queryUserListSize(cardList);
        System.out.println("--------$$$$$$$$$$$$");
        System.out.println(System.currentTimeMillis() - t1);
        if (!userMergeResult.isEmpty()) {
            logger.warn("user_merge表存在重复的卡号-------->>>>userMergeResult:[{}]", userMergeResult);
        }

        final int averageQuantity  = quantity / Thread_NUMBERS;
        final long beginNumber = maxStartNumber;

        long ll1 = System.currentTimeMillis();

        final ExecutorService threadPool = new ThreadPoolExecutor(0,
                Thread_NUMBERS,
                0L,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
        final CountDownLatch countDownLatch = new CountDownLatch(Thread_NUMBERS);
        final List<TransactionStatus> transactionStatuses = new CopyOnWriteArrayList<TransactionStatus>();
        final List<Integer> flagList = new ArrayList<Integer>();

        try {
            for (int i = 1; i <= Thread_NUMBERS; i++) {
                final int currentLocation = i;
                threadPool.execute(new Runnable() {
                    @Override
                    public void run() {
                        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
                        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
                        TransactionStatus status = transactionManager.getTransaction(def);
                        transactionStatuses.add(status);

                        int cl = currentLocation;
                        long localThreadBeginNumber = beginNumber + (cl - 1) * averageQuantity;
                        List<CardAccount> cardAccountList = new LinkedList<CardAccount>();
                        int totalNumber = averageQuantity;
                        if (cl == Thread_NUMBERS) {
                            totalNumber += quantity % Thread_NUMBERS;
                        }

                        for (int j = 1; j <= totalNumber; j++) {
                            String cardId = appId + String.format("%0" + lengthNumber + "d", localThreadBeginNumber) + lengthNumber;
                            //检查生成的阅读卡是否重复，重复则不插入
                            int flag = 0;
                            for (String dupCardId : userMergeResult) {
                                if (dupCardId.equals(cardId)) {
                                    flag = 1;
                                    break;
                                }
                            }
                            if (flag == 1) {
                                continue;
                            }
                            CardAccount cardAccount = new CardAccount();
                            cardAccount.setAppId(appId);
                            cardAccount.setActivateStatus((short) 0);
                            cardAccount.setActivateTime(activateTime);
                            cardAccount.setUseEndTime(useEndTime);
                            cardAccount.setTimeLength(timeLength);
                            cardAccount.setBatchId(batchId);
                            cardAccount.setCardIncrement((int)localThreadBeginNumber);
                            cardAccount.setCardIncrementNumber(lengthNumber);
                            cardAccount.setCardNumber(cardId);
                            cardAccount.setCardPassword("123");
                            localThreadBeginNumber++;
                            cardAccountList.add(cardAccount);
                        }
                        try {
                            if (!cardAccountList.isEmpty()) {
                                cardAccountMapper.insertCardBatch(cardAccountList);
                                userMergeMapper.insertUserInfoBatch(cardAccountList);
                                appAccountMapper.insertCardInfoBatch(cardAccountList);
                            }
                            countDownLatch.countDown();
                        } catch (Exception e) {
                            logger.warn("插入阅读卡异常---->>>>appId:[{}], batchId:[{}], lengthNumber:[{}]", appId, batchId, lengthNumber);
                            flagList.add(1);
                            threadPool.shutdownNow();
                            while(countDownLatch.getCount() > 0) {
                                countDownLatch.countDown();
                            }
                        }
                    }
                });
            }
        } finally {
            threadPool.shutdown();
        }

        try {
            countDownLatch.await();

            if (flagList.isEmpty()) {
                for (TransactionStatus transactionStatus : transactionStatuses) {
                    transactionManager.commit(transactionStatus);
                }
            } else {
                for (TransactionStatus transactionStatus : transactionStatuses) {
                    transactionStatus.setRollbackOnly();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        long ll2 = System.currentTimeMillis() - ll1;
        System.out.println("话费的时间：" + ll2);

        return true;
    }

    @Override
    protected DaoInterface getDao() {
        return cardAccountMapper;
    }
}
